# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MyRid
                                 A QGIS plugin
 MyRid
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-13
        git sha              : $Format:%H$
        copyright            : (C) 2023 by test
        email                : test@163.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os,json,time

from pyproj import Proj, transform
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QUrl, QCoreApplication, Qt, pyqtSignal, QSize, \
    QObject
from qgis.PyQt.QtGui import QIcon, QCloseEvent, QColor, QBrush
from qgis.PyQt.QtWidgets import QAction, QListWidgetItem
from qgis.PyQt.QtWidgets import QAction, QDialog, QMessageBox, QTableWidgetItem, QMenu, QTableWidget, QWidget, \
    QApplication, QHeaderView, QLabel, QLineEdit, QGridLayout, QComboBox, QToolBar, QMainWindow
from qgis.PyQt import QtWidgets,uic
from qgis._core import QgsMapLayerType, QgsFeature, QgsGeometry, QgsGeometryCollection, QgsWkbTypes, QgsProject, \
    QgsLayerTreeNode, QgsFeatureRequest, QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsAbstractGeometry, \
    QgsRectangle, QgsVectorLayerExporter, QgsVectorLayer, QgsDataSourceUri, QgsMapToPixel, QgsPoint, QgsLineString, \
    QgsPointXY

from qgis.core import (
    QgsApplication, QgsTask, QgsMessageLog, Qgis
    )

from shapely import MultiLineString

from .lib.Bubble import BubbleLabel
from qgis._gui import QgsRubberBand, QgsMapToolEdit, QgsMapToolEmitPoint, QgsMapToolIdentifyFeature
from time import sleep
from collections import OrderedDict
from .pyqss import Qss
from shapely.geometry import Point,Polygon,LineString
import numpy as np
from .lib.dbconn import cursor,db_conn_dict
from .lib.common import parseConfig
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from  .ui.AttrPainterDialog import Ui_Dialog
from .lib.common import getCrossFieldsInfo, getRidFieldsInfo
from .lib.geohash import geo_encode
from .src.osm2road import downloadOsm,roadData2Postgresql,getRoadList
from .src.road2rid import roadInit,getRidList,getLinkList
import os.path
from .src.road2rid import road2rid_signal,road2rid
from .src.rid2openlr import rid2openlr, link2openlr, convertSingle
from .src.openlr2match import singleDecode


class MyRid:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.rubberBand = []

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MyRid_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        # self.menu = self.tr(u'&RID Tools Toolbar')

        self.toolbar = self.iface.addToolBar('MyRid Tools Toolbar')
        self.toolbar.setObjectName('MyRidToolsToolbar')
        self.current_select_tab = None

        self.config = parseConfig()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.dock = Ui_Dialog()

        self.dockwidget = None
        self.dockwidgetRid = None

        self.dockwidgetLink = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MyRid Tools Toolbar', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # -------------------------------获取OSM数据------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/downloadOSM.png')
        self.downloadOSMAction = QAction(icon, self.tr('获取OSM数据'), self.iface.mainWindow())
        self.downloadOSMAction.setObjectName('stDownloadOSM')
        self.downloadOSMAction.triggered.connect(lambda: self.download_osm())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.downloadOSMAction)
        self.toolbar.addAction(self.downloadOSMAction)
        # -------------------------------道路数据入库------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/RoadData2Postgresql.png')
        self.roadData2PostgresqlAction = QAction(icon, self.tr('道路数据入库'), self.iface.mainWindow())
        self.roadData2PostgresqlAction.setObjectName('stRoadDataPostgresql')
        self.roadData2PostgresqlAction.triggered.connect(lambda: self.road_data_postgresql())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.roadData2PostgresqlAction)
        self.toolbar.addAction(self.roadData2PostgresqlAction)
        self.toolbar.addSeparator()
        # -------------------------------道路列表----------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/road_list.png')
        self.RoadListAction = QAction(icon, self.tr('道路列表'), self.iface.mainWindow())
        self.RoadListAction.setObjectName('stRoadList')
        self.RoadListAction.triggered.connect(lambda: self.get_road_list())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.RoadListAction)
        self.toolbar.addAction(self.RoadListAction)
        # -------------------------------手工合并路口------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/mergeCross.png')
        self.crossMergeAction = QAction(icon, self.tr('合并路口'), self.iface.mainWindow())
        self.crossMergeAction.setObjectName('stCrossMerge')
        self.crossMergeAction.triggered.connect(lambda: self.cross_merge())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.crossMergeAction)
        self.toolbar.addAction(self.crossMergeAction)
        # -------------------------------标记岔口------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/markNoCross.png')
        self.crossNoMarkAction = QAction(icon, self.tr('标记岔口'), self.iface.mainWindow())
        self.crossNoMarkAction.setObjectName('stCrossNoMark')
        self.crossNoMarkAction.triggered.connect(lambda: self.cross_nomark())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.crossNoMarkAction)
        self.toolbar.addAction(self.crossNoMarkAction)
        # -------------------------------手工打断道路------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/road_cut.svg')
        self.cutRoadAction = QAction(icon, self.tr('打断道路'), self.iface.mainWindow())
        self.cutRoadAction.setObjectName('stCutRoad')
        self.cutRoadAction.triggered.connect(lambda: self.road_cut())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.cutRoadAction)
        self.toolbar.addAction(self.cutRoadAction)
        # -------------------------------手工删除道路------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/road_delete.svg')
        self.deleteRoadAction = QAction(icon, self.tr('删除道路'), self.iface.mainWindow())
        self.deleteRoadAction.setObjectName('stDeleteRoad')
        self.deleteRoadAction.triggered.connect(lambda: self.road_delete())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.deleteRoadAction)
        self.toolbar.addAction(self.deleteRoadAction)
        # -------------------------------手工合并道路------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/mergeRoad.png')
        self.crossMergeAction = QAction(icon, self.tr('合并道路'), self.iface.mainWindow())
        self.crossMergeAction.setObjectName('stCrossMerge')
        self.crossMergeAction.triggered.connect(lambda: self.road_merge())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.crossMergeAction)
        self.toolbar.addAction(self.crossMergeAction)
        self.toolbar.addSeparator()
        # -------------------------------RID数据初始化------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/rid_init.png')
        self.roadInitAction = QAction(icon, self.tr('RID数据初始化'), self.iface.mainWindow())
        self.roadInitAction.setObjectName('stRoadInit')
        self.roadInitAction.triggered.connect(lambda: self.road_init())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.roadInitAction)
        self.toolbar.addAction(self.roadInitAction)
        # -------------------------------道路RID生成------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/ridGenerate.png')
        self.ridSingleGenerateAction = QAction(icon, self.tr('道路RID生成'), self.iface.mainWindow())
        self.ridSingleGenerateAction.setObjectName('stRidSingleGenerate')
        self.ridSingleGenerateAction.triggered.connect(lambda: self.rid_single_generate())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.ridSingleGenerateAction)
        self.toolbar.addAction(self.ridSingleGenerateAction)
        # -------------------------------RID全量生成------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/ridGenerate.png')
        self.ridGenerateAction = QAction(icon, self.tr('RID全量生成'), self.iface.mainWindow())
        self.ridGenerateAction.setObjectName('stRidGenerate')
        self.ridGenerateAction.triggered.connect(lambda: self.rid_generate())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.ridGenerateAction)
        self.toolbar.addAction(self.ridGenerateAction)
        self.toolbar.addSeparator()
        # -------------------------------RID数据列表-------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/rid_list.png')
        self.ridListAction = QAction(icon, self.tr('RID数据列表'), self.iface.mainWindow())
        self.ridListAction.setObjectName('stRidList')
        self.ridListAction.triggered.connect(lambda: self.get_rid_list())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.ridListAction)
        self.toolbar.addAction(self.ridListAction)
        # -------------------------------路口信息维护------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/cross_info.png')
        self.crossEditAction = QAction(icon, self.tr('路口信息'), self.iface.mainWindow())
        self.crossEditAction.setObjectName('stCrossEdit')
        self.crossEditAction.triggered.connect(lambda: self.edit_features('cross'))
        self.iface.addPluginToVectorMenu('MyRid Tools', self.crossEditAction)
        self.toolbar.addAction(self.crossEditAction)
        # -------------------------------路段信息维护------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/rid_info.png')
        self.ridEditAction = QAction(icon, self.tr('路段信息'), self.iface.mainWindow())
        self.ridEditAction.setObjectName('stRidEdit')
        self.ridEditAction.triggered.connect(lambda: self.edit_features('rid'))
        self.iface.addPluginToVectorMenu('MyRid Tools', self.ridEditAction)
        self.toolbar.addAction(self.ridEditAction)
        self.toolbar.addSeparator()
        # -------------------------------LINK-RID匹配------------------------------------------

        icon = QIcon(self.plugin_dir + '/images/road_list.png')
        self.LinkListAction = QAction(icon, self.tr('LINK列表'), self.iface.mainWindow())
        self.LinkListAction.setObjectName('stLinkList')
        self.LinkListAction.triggered.connect(lambda: self.get_link_list(''))
        self.iface.addPluginToVectorMenu('MyRid Tools', self.LinkListAction)
        self.toolbar.addAction(self.LinkListAction)

        icon = QIcon(self.plugin_dir + '/images/link_view.png')
        self.loadLinkAction = QAction(icon, self.tr('加载高德Link'), self.iface.mainWindow())
        self.loadLinkAction.setObjectName('stLoadLink')
        self.loadLinkAction.triggered.connect(lambda: self.load_links())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.loadLinkAction)
        self.toolbar.addAction(self.loadLinkAction)

        icon = QIcon(self.plugin_dir + '/images/rid_single_lst.png')
        self.ridOpenLrAction = QAction(icon, self.tr('初始化Link数据'), self.iface.mainWindow())
        self.ridOpenLrAction.setObjectName('stInitLinkData')
        self.ridOpenLrAction.triggered.connect(lambda: self.rid_openlr())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.ridOpenLrAction)
        self.toolbar.addAction(self.ridOpenLrAction)

        icon = QIcon(self.plugin_dir + '/images/rid_multi.png')
        self.ridLinkAction = QAction(icon, self.tr('Rid生成OpenLr'), self.iface.mainWindow())
        self.ridLinkAction.setObjectName('stRidOpenLr')
        self.ridLinkAction.triggered.connect(lambda: self.rid_set_links())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.ridLinkAction)
        self.toolbar.addAction(self.ridLinkAction)

        icon = QIcon(self.plugin_dir + '/images/rid_multi.png')
        self.ridMatchLinkAction = QAction(icon, self.tr('Rid匹配OpenLr'), self.iface.mainWindow())
        self.ridMatchLinkAction.setObjectName('stRidMatch')
        self.ridMatchLinkAction.triggered.connect(lambda: self.rid_match_links())
        self.iface.addPluginToVectorMenu('MyRid Tools', self.ridMatchLinkAction)
        self.toolbar.addAction(self.ridMatchLinkAction)

        self.toolbar.addSeparator()
        # --------------------------------配置管理------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/par_config.png')
        self.parConfigAction = QAction(icon, self.tr('配置管理123'), self.iface.mainWindow())
        self.parConfigAction.setObjectName('stParConfig')
        json_file = self.plugin_dir + '/config/config.json'
        json_file_bak = self.plugin_dir + '/config/config_original.json'
        self.parConfigAction.triggered.connect(lambda: self.par_config(json_file, json_file_bak))
        self.iface.addPluginToVectorMenu('RID Tools', self.parConfigAction)
        self.toolbar.addAction(self.parConfigAction)

        # --------------------------------测试------------------------------------------
        icon = QIcon(self.plugin_dir + '/images/par_config.png')
        self.testAction = QAction(icon, self.tr('测试'), self.iface.mainWindow())
        self.testAction.setObjectName('stParConfig')

        self.testAction.triggered.connect(lambda: self.test_test())
        self.iface.addPluginToVectorMenu('RID Tools', self.testAction)
        #self.toolbar.addAction(self.testAction)

        # will be set False in run()
        self.first_start = True
        QgsProject.instance().read(self.data_folder()+"myrid.qgs")



    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        # self.iface.removeToolBarIcon(self.ridVersionAction)
        self.iface.removeToolBarIcon(self.crossEditAction)
        self.iface.removeToolBarIcon(self.crossMergeAction)
        # remove the toolbar
        del self.toolbar


    def run(self):
        """Run method that performs all the real work"""
        from .ui.pickRoadName import Ui_Dialog
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = PickDialog(self.iface)
        # init system configure
        cross_fields_info = getCrossFieldsInfo()
        field_lst = []
        for field_name, attr_value in cross_fields_info.items():
            #if field_name in feature_fields_name:
            field_lst.append(field_name)
        #    print(field_name)


        self.calc_id_location = {
            "inter_name_idx": field_lst.index('inter_name') if 'inter_name' in field_lst else None,
            "interleveltype_idx": field_lst.index('interleveltype') if 'interleveltype' in field_lst else None,
        }

        self.dlg.pick_road_btn.clicked.connect(lambda: self.pick_rid_road_name(['inter_id','inter_name', 'is_signlight']))

        # show the dialog
        self.dlg.show()


        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def data_folder(self):
        return os.path.dirname(os.path.abspath(__file__)) + "/data/"

    def test_test(self):
        print('test.......')
        # Create a few tasks on_finished=self.completed,
        #task1 = QgsTask.fromFunction('Waste cpu 1', self.doSomething,p=111 ,wait_time=3)
        #QgsApplication.taskManager().addTask(task1)
        #while QgsApplication.taskManager().countActiveTasks() > 0:
        #    QCoreApplication.processEvents()
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))[0]
        print(vlayer.renderer().symbol().symbolLayers()[0].properties())
        print(vlayer.renderer().symbol().symbolLayers()[1].properties())

        print('symbolLayers->'+str(len(vlayer.renderer().symbol())))

    def doSomething(self,task,p, wait_time):
        """
        Raises an exception to abort the task.
        Returns a result if success.
        The result will be passed, together with the exception (None in
        the case of success), to the on_finished method.
        If there is an exception, there will be no result.
        """
        import random
        print('p--->'+p)
        QgsMessageLog.logMessage('Started task {}'.format(task.description()),
                                 'TaskFromFunction', Qgis.Info)
        wait_time = wait_time / 100
        total = 0
        iterations = 0
        for i in range(100):
            sleep(wait_time)
            # use task.setProgress to report progress
            task.setProgress(i)
            arandominteger = random.randint(0, 500)
            total += arandominteger
            iterations += 1
            # check task.isCanceled() to handle cancellation
            if task.isCanceled():
                return None
            # raise an exception to abort the task
            if arandominteger == 42:
                raise Exception('bad value!')
        QgsMessageLog.logMessage('finish task {}'.format(task.description()),
                                 'TaskFromFunction', Qgis.Info)


        return {'total': total, 'iterations': iterations,
                'task': task.description()}

    # download osm
    def download_osm(self):
        print('download osm')
        self.finished = 0
        def _on_completed():
            self.finished += 1
        #ret, errMsg =downloadOsm(self,parseConfig().get('ad_code'),self.data_folder())

        task = QgsTask.fromFunction('download osm data', downloadOsm,
                                    ad_code=parseConfig().get('ad_code'), data_folder=self.data_folder())
        task.taskCompleted.connect(_on_completed)
        QgsApplication.taskManager().addTask(task)
        while QgsApplication.taskManager().countActiveTasks() > 0:
            QCoreApplication.processEvents()
        if self.finished>0:
            self.onMsgShow('OSM 数据下载完成！')

    # road data to postgresql
    def road_data_postgresql(self):
        print('road data to postgresql')
        self.finished = 0

        def _on_completed():
            self.finished += 1
        msg = '提示:当前导入数据会覆盖原有数据,是否继续？'
        res = QMessageBox.question(self.toolbar, '消息', msg, QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)  # 两个按钮是否， 默认No则关闭这个提示框

        if res == QMessageBox.Yes:
            conn = parseConfig().get('conn')
            #ret, errMsg =roadData2Postgresql(QgsProject.instance(),conn,self.data_folder())
            # roadData2Postgresql( self.data_folder())
            task = QgsTask.fromFunction('road data to postgresql', roadData2Postgresql,
                                         data_folder=self.data_folder())
            task.taskCompleted.connect(_on_completed)
            QgsApplication.taskManager().addTask(task)
            while QgsApplication.taskManager().countActiveTasks() > 0:
                QCoreApplication.processEvents()
            if self.finished==0:
                self.onMsgShow('道路数据入库失败！')
            else:
                # 修复：添加图层检查，避免索引错误
                vlayers = QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))
                if vlayers and len(vlayers) > 0:
                    vlayer = vlayers[0]
                    xform = QgsCoordinateTransform(vlayer.crs(),
                                                   self.canvas.mapSettings().destinationCrs(), QgsProject.instance())
                    self.canvas.setExtent(xform.transform(vlayer.extent().buffered((vlayer.extent().height() + vlayer.extent().width()) / 20.0)))
                    self.canvas.refresh()
                    self.onMsgShow('道路数据入库已完成！')
                    self.get_road_list()
                else:
                    self.onMsgShow('数据入库完成，但图层加载失败。请检查数据库连接。')

    #road list
    def get_road_list(self):
        print('road list')
        vlayers = QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))
        # print(layer.name())
        if not vlayers or vlayers[0].type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取道路数据失败，请先导入道路数据！")
            return

        if self.dockwidget == None:
            self.dockwidget = RoadListDialog()
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.listWidget.itemClicked.connect(self.pick_road_name)
            self.dockwidget.pushButton.clicked.connect(self.pick_road_list)
            self.dockwidget.lineEdit.returnPressed.connect(self.pick_road_list)

        self.dockwidget.listWidget.clear()
        conn = parseConfig().get('conn')
        lst_road=getRoadList(conn,'')
        for road in lst_road:
            self.dockwidget.listWidget.addItem(QListWidgetItem(road[0]))
        if len(lst_road)==1:
            self.pick_road_name(self,self.dockwidget.listWidget.items[0])
        # show the dialog
        self.dockwidget.show()

    def pick_road_list(self):
        self.dockwidget.listWidget.clear()
        conn = parseConfig().get('conn')
        lst_road = getRoadList(conn,self.dockwidget.lineEdit.text())
        for road in lst_road:
            self.dockwidget.listWidget.addItem(QListWidgetItem(road[0]))
        if len(lst_road)==1:
            print(lst_road[0][0])
            self.pick_road_name(QListWidgetItem(lst_road[0][0]))

    def road_cut(self):
        print('road cut...')
        # print(layer.name())
        if not QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment')) or not QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes')) or not QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0] or QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0].type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取道路数据失败，请先导入道路数据！")
            return
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0]
        slayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))[0]

        select_features = vlayer.selectedFeatures()
        if select_features == []:
            # print(QMessageBox.warning(self.toolbar, '提示', '没有选中要素！'))
            msg = '请选择至少一条道路进行拆分！'
            self.onMsgShow(msg)
            return

        #self.pointTool = QgsMapToolEmitPoint(self.canvas)
        #self.pointTool.canvasClicked.connect(self.handleMouseDown)
        #self.canvas.setMapTool(self.pointTool)
        self.mapTool = QgsMapToolIdentifyFeature(self.canvas)
        self.mapTool.setLayer(slayer)
        self.canvas.setMapTool(self.mapTool)
        self.mapTool.featureIdentified.connect(self.handleMouseDown)
        print('ok....')

    def handleMouseDown(self,selected_cross):
        if not selected_cross:
            self.onMsgShow('请先选择分割路段所在路口！')
            return
        spoint=selected_cross.geometry()
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0]
        #print('POINT:'+str(spoint[0])+","+str(spoint[1]))
        #pt=self.pointTool.toLayerCoordinates(vlayer,spoint)
        #print('toLayerCoordinates:'+str(pt.x())+","+str(pt.y()))
        select_features = vlayer.selectedFeatures()
        vlayer.startEditing()
        result=-1
        for feature in select_features:
            print(feature.geometry().asWkt())
            nearGeom = feature.geometry().nearestPoint(spoint).asPoint()
            #cutGeom = QgsGeometry.fromWkt('LineString( '+str(pt.x())+' '+str(pt.y())+', '+str(nearGeom.x())+' '+str(nearGeom.y())+' )')
            cutGeom = [QgsPointXY( spoint.asPoint().x(),spoint.asPoint().y()), QgsPointXY(nearGeom.x(),nearGeom.y())]
            #cutGeom = QgsLineString([QgsPoint(pt.x(),pt.y()), QgsPoint(nearGeom.x(),nearGeom.y())])
            print(cutGeom)
            #splitGeom = QgsGeometry()
            #if feature.geometry().intersects(cutGeom):
            result, new_geometries, point_xy = feature.geometry().splitGeometry(cutGeom,True,False)
            if int(result)==0:
                print(new_geometries)
                vlayer.deleteFeature(feature.id())
                for i in range(len(new_geometries)):
                        newFeature=QgsFeature(feature.fields())
                        for field in feature.fields():
                            if field.name() != 'gid':
                                newFeature[field.name()] = feature[field.name()]
                        if i==0:
                            newFeature['tnode'] = selected_cross['osmid']
                        else:
                            newFeature['fnode'] = selected_cross['osmid']
                        newFeature.setGeometry(new_geometries[i])
                        vlayer.addFeature(newFeature)
                        self.highlight(new_geometries[i])
        try:
            vlayer.triggerRepaint()
            vlayer.commitChanges()
        except Exception as e:
            print('Exception in road cut', e)

        if int(result) == 0:
            self.onMsgShow('路段分割完成！')
        else:
            self.onMsgShow('路段分割失败！')

    def road_delete(self):
        print('road delete...')
        # print(layer.name())
        if not QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment')) or not QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0] or QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0].type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取道路数据失败，请先导入道路数据！")
            return
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0]

        select_features = vlayer.selectedFeatures()
        if select_features == []:
            # print(QMessageBox.warning(self.toolbar, '提示', '没有选中要素！'))
            msg = '没有选中道路！'
            self.onMsgShow(msg)
            return
        alter_msg = ''
        msg = '%s \n提示:当前批量删除道路数据并且不能恢复,是否继续？' % alter_msg
        res = QMessageBox.question(self.toolbar, '消息', msg, QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)  # 两个按钮是否， 默认No则关闭这个提示框
        if res == QMessageBox.Yes:
            try:
                vlayer.startEditing()
                for feature in select_features:
                    vlayer.deleteFeature(feature.id())
                vlayer.triggerRepaint()
                vlayer.commitChanges()
            except Exception as e:
                    print('Exception in road delete', e)
            self.onMsgShow('道路删除成功！')

    #rid list
    def get_rid_list(self):
        print('rid list')
        vlayers = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))
        slayers = QgsProject.instance().mapLayersByName(parseConfig().get('tab_cross'))
        # print(layer.name())
        if not vlayers or not slayers or vlayers[0].type() != QgsMapLayerType.VectorLayer or slayers[0].type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取RID数据失败，请先导入RID数据！")
            return

        if self.dockwidgetRid == None:
            self.dockwidgetRid = RidListDialog()
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidgetRid)
            self.dockwidgetRid.listWidget1.itemClicked.connect(self.pick_rid_name)
            self.dockwidgetRid.listWidget2.itemClicked.connect(self.pick_cross_name)
            self.dockwidgetRid.pushButton.clicked.connect(self.pick_rid_list)
            self.dockwidgetRid.lineEdit.returnPressed.connect(self.pick_rid_list)

        self.dockwidgetRid.listWidget1.clear()
        self.dockwidgetRid.listWidget2.clear()
        conn = parseConfig().get('conn')
        lst_rids,lst_crosss = getRidList(conn,'')
        for rid in lst_rids:
            rid_item = QListWidgetItem(rid[0])
            rid_item.setData(Qt.UserRole, rid[1])
            self.dockwidgetRid.listWidget1.addItem(rid_item);

        for cross in lst_crosss:
            cross_item = QListWidgetItem(cross[0])
            cross_item.setData(Qt.UserRole, cross[1])
            self.dockwidgetRid.listWidget2.addItem(cross_item);
        # show the dialog
        self.dockwidgetRid.show()

    def pick_rid_list(self):
        self.dockwidgetRid.listWidget1.clear()
        conn = parseConfig().get('conn')
        lst_rids, lst_crosss = getRidList(conn,self.dockwidgetRid.lineEdit.text())
        for rid in lst_rids:
            rid_item = QListWidgetItem(rid[0])
            rid_item.setData(Qt.UserRole, rid[1])
            self.dockwidgetRid.listWidget1.addItem(rid_item)
        # if len(lst_rid)==1:
        #     print(lst_rid[0][0])
        #     self.pick_rid_name(QListWidgetItem(lst_rid[0][0]))

    #link list
    def get_link_list(self,selectedRid):
        print('link list')
        vlayers = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))

        if self.dockwidgetLink == None:
            self.dockwidgetLink = LinkListDialog()
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidgetLink)
            self.dockwidgetLink.listWidget.itemClicked.connect(self.pick_link)
            self.dockwidgetLink.pick_link.clicked.connect(self.insert_link)
            self.dockwidgetLink.del_link.clicked.connect(self.del_link)
            #self.dockwidget.lineEdit.returnPressed.connect(self.pick_road_list)

        self.dockwidgetLink.listWidget.clear()
        conn = parseConfig().get('conn')
        lst_link= getLinkList(conn,selectedRid)
        for link in lst_link:
            link_item = QListWidgetItem(link[0])
            link_item.setData(Qt.UserRole, link[1])
            self.dockwidgetLink.listWidget.addItem(link_item)
        # if len(lst_link)==1:
        #     link_item = QListWidgetItem(lst_link[0][0])
        #     link_item.setData(Qt.UserRole, lst_link[0][1])
        #     self.pick_link(self,link_item)
        # show the dialog
        self.dockwidgetLink.show()

    def del_link(self):

        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_link'))[0]
        if not vlayer or vlayer.type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取路网LINK数据失败，请先导入路网LINK数据！")
            return

        select_features = vlayer.selectedFeatures()
        if select_features == []:
            msg = '没有选中Link！'
            self.onMsgShow(msg)
            return

        sql_delete_link = """
                            DELETE FROM "{2}"."{0}" WHERE "forwardroa"='{1}';
                    """.format(parseConfig().get('tab_axf'),
                               str(self.dockwidgetLink.listWidget.currentItem().text()),
                               parseConfig().get('schema'))

        print(sql_delete_link)
        conn = parseConfig().get('conn')

        cursor(conn, sql_delete_link)
        conn.commit()
        print('delete link success->' + str(self.dockwidgetLink.listWidget.currentItem().text()))
        self.get_link_list(str(self.dockwidgetRid.listWidget1.currentItem().data(Qt.UserRole)))
        self.onMsgShow('Rid-Link挂接关系删除成功！')


    def insert_link(self):
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_link'))[0]
        if not vlayer or vlayer.type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取路网LINK数据失败，请先导入路网LINK数据！")
            return

        select_features = vlayer.selectedFeatures()
        if select_features == []:
            # print(QMessageBox.warning(self.toolbar, '提示', '没有选中要素！'))
            msg = '没有选中要素！'
            self.onMsgShow(msg)
            return

        for feature in select_features:

            #print(feature.geometry())
            sql_insert_link ="""
                    INSERT INTO "{5}"."{0}"("rid", "forwardroa", "seq_no", "dir", "adcode", "road_class", "p_modify", "geom") 
                    select '{1}' AS "rid",'{2}' AS "forwardroa", COALESCE ((SELECT max(seq_no) FROM "{5}"."{0}" where rid='{1}')::INTEGER,0)+1 AS "seq_no", 1 AS "dir", '370100' AS "adcode",{3} AS "road_class", 1 AS "p_modify", ST_GEOMFROMTEXT('{4}') AS "geom";
            """.format(parseConfig().get('tab_axf'), str(self.dockwidgetRid.listWidget1.currentItem().data(Qt.UserRole)), str(feature['forwardroadid64']), str(feature['road_class']), str(feature.geometry().asWkt()),
                       parseConfig().get('schema'))

            #print(sql_insert_link)
            conn = parseConfig().get('conn')

            cursor(conn, sql_insert_link)
            conn.commit()

            self.get_link_list(str(self.dockwidgetRid.listWidget1.currentItem().data(Qt.UserRole)))
            print('insert link->'+str(feature['forwardroadid64']))


    def pick_link(self,item):
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_link'))[0]
        if not vlayer or vlayer.type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取路网LINK数据失败，请先导入路网LINK数据！")
            return

        if len(item.text()) > 0:
            expression = u'"forwardroadid64" = {0}'.format(item.text())

        request = QgsFeatureRequest().setFilterExpression(expression)
        matches = 0
        flash_filter_featuers = []
        selected_fid = []
        extent = QgsRectangle()
        for f in vlayer.getFeatures(request):
            matches += 1
            flash_filter_featuers.append(f)
            selected_fid.append(f.id())

        print('matches:' + str(matches))
        # for flash_feature in flash_filter_featuers:
        #     extent.combineExtentWith(flash_feature.geometry().boundingBox())
        # self.highlights(flash_filter_featuers, vlayer)
        # 将这些要素添加到选定的列表
        self.iface.mapCanvas().setSelectionColor(QColor("#ff0000"))
        # vlayer.removeSelection()
        vlayer.select(selected_fid)
        # print(extent)
        # xform = QgsCoordinateTransform(vlayer.crs(),
        #                                self.canvas.mapSettings().destinationCrs(), QgsProject.instance())
        # self.canvas.setExtent(xform.transform(extent.buffered((extent.height() + extent.width()) / 20.0)))
        self.canvas.refresh()

    def pick_rid_name(self,item):
        print('item clicked: '+str(item.data(Qt.UserRole)))
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))[0]
        if not vlayer or vlayer.type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取路网RID数据失败，请先导入路网RID数据！")
            return

        if len(item.text()) > 0:
            expression = "rid = '{0}'".format(item.data(Qt.UserRole))
        request = QgsFeatureRequest().setFilterExpression(expression)
        matches = 0
        flash_filter_featuers = []
        selected_fid = []
        extent = QgsRectangle()
        for f in vlayer.getFeatures(request):
            matches += 1
            flash_filter_featuers.append(f)
            selected_fid.append(f.id())

        print('matches:' + str(matches))
        for flash_feature in flash_filter_featuers:
            extent.combineExtentWith(flash_feature.geometry().boundingBox())
        #self.highlights(flash_filter_featuers, vlayer)
        # 将这些要素添加到选定的列表
        self.iface.mapCanvas().setSelectionColor(QColor("#ffff00"))
        vlayer.removeSelection()
        vlayer.select(selected_fid)
        self.get_link_list(str(item.data(Qt.UserRole)))
        print(extent)
        xform = QgsCoordinateTransform(vlayer.crs(),
                                       self.canvas.mapSettings().destinationCrs(), QgsProject.instance())
        self.canvas.setExtent(xform.transform(extent.buffered((extent.height() + extent.width()) / 20.0)))
        self.canvas.refresh()

    def pick_cross_name(self,item):
        print('item clicked: '+str(item.data(Qt.UserRole)))
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_cross'))[0]
        if not vlayer or vlayer.type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取路网RID数据失败，请先导入路网RID数据！")
            return

        if len(item.text()) > 0:
            expression = "inter_id = '{0}'".format(item.data(Qt.UserRole))
        request = QgsFeatureRequest().setFilterExpression(expression)
        matches = 0
        flash_filter_featuers = []
        selected_fid = []
        extent = QgsRectangle()
        for f in vlayer.getFeatures(request):
            matches += 1
            flash_filter_featuers.append(f)
            selected_fid.append(f.id())

        print('matches:' + str(matches))

        for flash_feature in flash_filter_featuers:
            extent.combineExtentWith(flash_feature.geometry().boundingBox())
        #self.highlights(flash_filter_featuers, vlayer)
        self.iface.mapCanvas().setSelectionColor(QColor("#ffff00"))
        vlayer.removeSelection()
        vlayer.select(selected_fid)
        print(extent)

        xform = QgsCoordinateTransform(vlayer.crs(),
                                       self.canvas.mapSettings().destinationCrs(), QgsProject.instance())
        self.canvas.setExtent(xform.transform(extent.buffered((extent.height() + extent.width()) / 20.0)))
        self.canvas.refresh()

    def pick_road_name(self,item):
        print('item clicked: '+str(item.text()))
        #vlayer = self.canvas.currentLayer()
        vlayer= QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0]
        if not QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment')) or not vlayer or vlayer.type() != QgsMapLayerType.VectorLayer :
            QMessageBox.warning(None, u"Error", u"获取道路数据失败，请先导入道路数据！")
            return
        #self.iface.setActiveLayer(vlayer)
        if len(item.text()) >0:
            expression = "name = '{0}'".format( item.text())
        request = QgsFeatureRequest().setFilterExpression(expression)
        matches = 0
        flash_filter_featuers = []
        selected_fid = []

        extent=QgsRectangle()
        for f in vlayer.getFeatures(request):
            matches += 1
            flash_filter_featuers.append(f)
            selected_fid.append(f.id())

        print('matches:'+str(matches))

        for flash_feature in flash_filter_featuers:
            extent.combineExtentWith(flash_feature.geometry().boundingBox())
        #self.highlights(flash_filter_featuers,vlayer)

        # 将这些要素添加到选定的列表
        self.iface.mapCanvas().setSelectionColor(QColor("#ffff00"))
        vlayer.removeSelection()
        vlayer.select(selected_fid)
        print(extent)
        xform = QgsCoordinateTransform(vlayer.crs(),
                                       self.canvas.mapSettings().destinationCrs(),QgsProject.instance())
        self.canvas.setExtent(xform.transform(extent.buffered((extent.height() + extent.width()) / 20.0)))
        self.canvas.refresh()

    # road init
    def road_init(self):
        print('road init')
        msg = '提示:当前初始化数据会覆盖原有数据,是否继续？'
        res = QMessageBox.question(self.toolbar, '消息', msg, QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)  # 两个按钮是否， 默认No则关闭这个提示框
        msg = '初始化数据失败！'
        if res == QMessageBox.Yes:
            #print('初始化数据结构....')
            parDict = parseConfig()
            conn = parDict.get('conn')
            schema = parDict.get('schema')
            tab_rid = parDict.get('tab_rid')
            tab_cross = parDict.get('tab_cross')
            tab_lane = parDict.get('tab_lane')
            tab_axf = parDict.get('tab_axf')
            roadInit(conn,schema,tab_cross,tab_rid,tab_lane,tab_axf)
            msg='初始化数据已完成！'
        self.onMsgShow(msg)

    def rid_single_generate(self):
        # print('rid generate')
        self.finished = 0
        def _on_completed():
            self.finished += 1
        alter_msg = ''
        if not self.dockwidget or not self.dockwidget.listWidget or  not self.dockwidget.listWidget.currentItem():
            QMessageBox.warning(None, u"Error", u"请在道路列表中选择要生成RID的道路！")
            return

        msg = '%s \n提示:当前生成RID数据产生会覆盖原有数据,是否继续？'%alter_msg
        res = QMessageBox.question(self.toolbar, '消息', msg, QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)  # 两个按钮是否， 默认No则关闭这个提示框

        if res  == QMessageBox.Yes:
            print('生成RID数据....')

            print('selected road name:'+self.dockwidget.listWidget.currentItem().text())
            task = QgsTask.fromFunction('road2rid signal...', road2rid_signal,road_name=self.dockwidget.listWidget.currentItem().text())
            task.taskCompleted.connect(_on_completed)
            QgsApplication.taskManager().addTask(task)
            while QgsApplication.taskManager().countActiveTasks() > 0:
                QCoreApplication.processEvents()
            if self.finished == 0:
                self.onMsgShow('生成RID数据失败！')
            else:
                #vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))[0]
                #self.canvas.setExtent(vlayer.extent())
                #xform = QgsCoordinateTransform(vlayer.crs(),
                #                               self.canvas.mapSettings().destinationCrs(), QgsProject.instance())
                #self.canvas.setExtent(xform.transform(
                #    vlayer.extent().buffered((vlayer.extent().height() + vlayer.extent().width()) / 20.0)))
                self.canvas.refresh()
                self.onMsgShow('生成RID数据已完成！')
                self.get_rid_list()

    # rid all generate
    def rid_generate(self):
        # print('rid generate')
        self.finished = 0
        def _on_completed():
            self.finished += 1
        alter_msg = ''
        msg = '%s \n提示:当前全量生成RID数据产生会覆盖原有数据,是否继续？'%alter_msg
        res = QMessageBox.question(self.toolbar, '消息', msg, QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)  # 两个按钮是否， 默认No则关闭这个提示框

        if res  == QMessageBox.Yes:
            print('生成RID数据....')

            task = QgsTask.fromFunction('road2rid all...', road2rid)
            task.taskCompleted.connect(_on_completed)
            QgsApplication.taskManager().addTask(task)
            while QgsApplication.taskManager().countActiveTasks() > 0:
                QCoreApplication.processEvents()
            if self.finished == 0:
                self.onMsgShow('生成RID数据失败！')
            else:
                vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))[0]
                # self.canvas.setExtent(vlayer.extent())
                xform = QgsCoordinateTransform(vlayer.crs(),
                                               self.canvas.mapSettings().destinationCrs(), QgsProject.instance())
                self.canvas.setExtent(xform.transform(
                vlayer.extent().buffered((vlayer.extent().height() + vlayer.extent().width()) / 20.0)))
                self.canvas.refresh()
                self.onMsgShow('生成RID数据已完成！')
                self.get_rid_list()

    def initTable(self,lst_name,widget):
        '''
        QTableWidget initialization
        '''
        for i in range(0,len(lst_name)):
            header = QTableWidgetItem(lst_name[i])
            header.setTextAlignment(Qt.AlignLeft)
            widget.setHorizontalHeaderItem(i, header)
        widget.resizeColumnsToContents()

    def edit_features(self,type):
        vlayer = self.canvas.currentLayer()
        if  type == 'rid' and (not vlayer  or not vlayer.name().__contains__(parseConfig().get('tab_rid'))):
            vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))
            if not vlayer or vlayer[0].type() != QgsMapLayerType.VectorLayer:
                QMessageBox.warning(None, u"Error", u"获取路网RID数据失败，请先导入路网RID数据！")
                return
            else:
                vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))[0]

        elif type == 'cross' and (not vlayer or not vlayer.name().__contains__(parseConfig().get('tab_cross'))):
            vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_cross'))
            if not vlayer or vlayer[0].type() != QgsMapLayerType.VectorLayer:
                QMessageBox.warning(None, u"Error", u"获取路网RID数据失败，请先导入路网RID数据！")
                return
            else:
                vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_cross'))[0]

        select_features = vlayer.selectedFeatures()

        if  select_features == []:
            print(QMessageBox.warning(self.toolbar, '提示', '%s没有选中要素！'%vlayer.name()))
            return

        if select_features != []:
            if len(select_features) >= 2:
                print(QMessageBox.warning(self.toolbar, '提示', '当前选中大于1个要素！'))
                return

        if len(select_features) == 1:
            feature = select_features[0]
            fields = feature.fields()
            tab_tile = ['Name', 'Value']
            self.highlight(feature.geometry())

            feature_fields_name = [field.name() for field in fields]

            if type == 'cross':
                # 获取配置中字段
                cross_fields_info = getCrossFieldsInfo()
                field_lst = []
                for field_name, attr_value in cross_fields_info.items():
                    if field_name in feature_fields_name:
                        field_lst.append(field_name)

                self.calc_id_location = {
                    "inter_name_idx": field_lst.index('inter_name') if 'inter_name' in field_lst else None,
                    "interleveltype_idx": field_lst.index('interleveltype') if 'interleveltype' in field_lst else None,
                }

                self.cross_dlg = AttrDialog2(self.iface)
                self.cross_dlg.show()
                cross_file = self.plugin_dir + '/config/config_cross.json'
                cross_file_bak = self.plugin_dir + '/config/config_cross_original.json'
                # 重新计算inter_id
                self.cross_dlg.recalc_btn.clicked.connect(lambda: self.recalc_hash(feature.geometry()))
                # 拾取计算路口名称
                self.cross_dlg.pick_btn.clicked.connect(lambda:self.pick_road_name('cross'))

            if type == 'rid':
                # 获取配置中字段
                cross_fields_info = getRidFieldsInfo()
                field_lst = []
                for field_name, attr_value in cross_fields_info.items():
                    if field_name in feature_fields_name:
                        field_lst.append(field_name)

                # 字段差异
                #diff_fields_one = set(list(cross_fields_info.keys())).difference(set(feature_fields_name))
                # diff_fields_two = set(feature_fields_name).difference(set(field_lst))
                #if len(diff_fields_one) > 0 :
                #    self.onMsgShow('参数配置中字段与地图要素字段差异：\n%s'%(',\n'.join(list(diff_fields_one))))
                    # return

                self.cross_dlg = RidDialog(self.iface)
                self.cross_dlg.show()
                cross_file = self.plugin_dir + '/config/config_rid.json'
                cross_file_bak = self.plugin_dir + '/config/config_rid_original.json'
                # 拾取起点终点计算路口rid
                # "isoneway_idx":field_lst.index('isoneway') if 'isoneway' in field_lst else None,
                self.calc_id_location = {
                    "startcrossid_idx" : field_lst.index('startcrossid') if 'startcrossid' in field_lst else None,
                    "endcrossid_idx" : field_lst.index('endcrossid') if 'endcrossid' in field_lst else None,
                    "pairsrid_idx" : field_lst.index('pairsrid') if 'pairsrid' in field_lst else None
                }
                self.cross_dlg.pick_btn.clicked.connect(lambda: self.pick_road_name('rid'))
            # 获取字段属性
            fea_attr = feature.attributes()
            # filter_fea_attr = [[field.name,fea_attr[i]] for i,field in enumerate(fields) if field.name() in field_lst  ]
            filter_fea_attr = {}
            for i, field in enumerate(fields):
                if field.name() in field_lst:
                    if fea_attr[i] is None:
                        current_attr = ''
                    else:
                        current_attr = fea_attr[i]
                    filter_fea_attr.update({field.name(): current_attr})
            # print(filter_fea_attr)
            # 参数修改
            self.cross_dlg.par_btn.clicked.connect(lambda: self.par_config(cross_file, cross_file_bak))
            # 提交
            self.cross_dlg.ok_btn.clicked.connect(lambda:self.cross_submit(vlayer,feature,self.cross_dlg))
            # 取消
            self.cross_dlg.cancel_btn.clicked.connect(self.cross_dlg.close)
            # 设置启用编辑 edit_id_btn
            self.cross_dlg.edit_id_btn.clicked.connect(lambda:self.ItemisEnable(0))
            if type == 'cross':
                # 设置启用编辑 edit_name_btn
                self.cross_dlg.edit_name_btn.clicked.connect(lambda:self.ItemisEnable(1))

            self.cross_dlg.tabWidget.setColumnCount(len(tab_tile))
            self.initTable(tab_tile, self.cross_dlg.tabWidget)
            self.cross_dlg.tabWidget.setRowCount(len(field_lst))
            # 重置
            self.cross_dlg.reset_btn.clicked.connect(lambda:self.tab_obj(field_lst,cross_fields_info,filter_fea_attr))
            self.cross_dlg.label.setText('当前图层:' + vlayer.name())
            self.tab_obj(field_lst,cross_fields_info,filter_fea_attr)

    #加载高德link数据
    def load_links(self):
        # 设置数据库连接参数
        qgs_uri = QgsDataSourceUri()
        # 设置主机，端口，数据库名称，用户名和密码
        qgs_uri.setConnection(parseConfig().get('dbinfo')['host'], str(parseConfig().get('dbinfo')['port']), parseConfig().get('dbinfo')['dbname'], parseConfig().get('dbinfo')['user'],
                              parseConfig().get('dbinfo')['pw'],sslmode=QgsDataSourceUri.SslMode.SslDisable)
        # 设置数据库架构，表名，几何列和可选项（WHERE 语句）
        qgs_uri.setDataSource(parseConfig().get('schema'), parseConfig().get('tab_link'), "geom","","gid")
        vlayer = QgsVectorLayer(qgs_uri.uri(False), parseConfig().get('tab_link'), "postgres")
        #print(vlayer)
        # if not vlayer.isValid():
        #     print("图层加载失败！")
        # else:
            # 将图层添加到当前项目
        QgsProject.instance().addMapLayer(vlayer)
        print("图层加载成功！")

    #Link -> openlr
    def rid_openlr(self):
        linklayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))
        if  not linklayer or  not linklayer[0].isValid():
            QMessageBox.warning(None, u"Error", u"获取RID数据失败，请先导入RID数据！")
            return

        self.finished = 0

        def _on_completed():
            self.finished += 1
        alter_msg = ''

        task = QgsTask.fromFunction('link2openlr signal...', link2openlr)
        task.taskCompleted.connect(_on_completed)
        QgsApplication.taskManager().addTask(task)
        while QgsApplication.taskManager().countActiveTasks() > 0:
            QCoreApplication.processEvents()
        if self.finished == 0:
            self.onMsgShow('生成Link数据失败！')
        else:
            self.canvas.refresh()
            self.onMsgShow('生成Link数据已完成！')

        print ("Link -> Openlr ")



    #rid 匹配 link
    def rid_set_links(self):
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_link'))
        linklayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))
        if not vlayer or not linklayer or not vlayer[0].isValid() or not linklayer[0].isValid():
            QMessageBox.warning(None, u"Error", u"获取LINK 或者RID数据失败，请先导入LINK 和 RID数据！")
            return

        self.finished = 0

        def _on_completed():
            self.finished += 1

        alter_msg = ''
        task = QgsTask.fromFunction('rid2openlr signal...', rid2openlr,str(self.dockwidgetRid.listWidget1.currentItem().data(Qt.UserRole)))
        task.taskCompleted.connect(_on_completed)
        QgsApplication.taskManager().addTask(task)
        while QgsApplication.taskManager().countActiveTasks() > 0:
            QCoreApplication.processEvents()
        if self.finished == 0:
            self.onMsgShow('生成OpenLr数据失败！')
        else:
            self.canvas.refresh()
            self.onMsgShow('生成OpenLr数据已完成！')
        print("RID匹配LINK")

    def rid_match_links(self):

        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_rid'))
        if not vlayer or  not vlayer[0].isValid() :
            QMessageBox.warning(None, u"Error", u"获取LINK 或者RID数据失败，请先导入LINK 和 RID数据！")
            return

        self.finished = 0

        def _on_completed():
            self.finished += 1

        alter_msg = ''
        #dct_dbinfo, tab_openlr, tab_output, openlr_code, par, schema, single_rid
        # openlr_code='C1NNqBoQGDL3A/8W/+UyBwAA'
        # single_rid='13NVT0B5TC013NV50B5TA00'   #str(self.dockwidgetRid.listWidget1.currentItem().data(Qt.UserRole))

        # singleDecode(parseConfig().get('db_info'),parseConfig().get('tab_rid'), parseConfig().get('tab_match'),parseConfig().get('par'),parseConfig().get('schema'),
        #              str(self.dockwidgetRid.listWidget1.currentItem().data(Qt.UserRole)))
        task = QgsTask.fromFunction('rid2openlr signal...',singleDecode,parseConfig().get('dbinfo'),parseConfig().get('tab_rid'), parseConfig().get('tab_output'),parseConfig().get('my_config'),parseConfig().get('schema'),
                                    str(self.dockwidgetRid.listWidget1.currentItem().data(Qt.UserRole)))

        task.taskCompleted.connect(_on_completed)
        QgsApplication.taskManager().addTask(task)
        while QgsApplication.taskManager().countActiveTasks() > 0:
            QCoreApplication.processEvents()
        if self.finished == 0:
            self.onMsgShow('Rid match link数据失败！')
        else:
            self.canvas.refresh()
            self.onMsgShow('Rid match link数据已完成！')

        print("Rid match link......")


    def ItemisEnable(self, row):
        # self.cross_dlg.
        item_info = self.cross_dlg.tabWidget.item(row, 1).data(Qt.DisplayRole)
        item = QTableWidgetItem()
        item.setData(Qt.DisplayRole, item_info)
        # item.setText(item_info)
        self.cross_dlg.tabWidget.setItem(row, 1, item)

    def tab_obj(self, field_lst, cross_fields_info, filter_fea_attr):
        for n in range(len(field_lst)):
            field_n = field_lst[n]
            field_info = cross_fields_info.get(field_n)
            field_values = field_info.get('value')
            field_translate = field_info.get('translate') if field_info.get('translate') else ''
            edit_status = field_info.get('style')
            # print(field_n)
            item = QTableWidgetItem()
            item.setData(Qt.DisplayRole, '%s(%s)' % (field_n, field_translate))
            self.cross_dlg.tabWidget.setItem(n, 0, item)

            if field_values == {}:
                item = QTableWidgetItem()
                # 设置不可编辑
                if edit_status is not None and edit_status == 'enabled_false':
                    item.setFlags(item.flags() & Qt.ItemIsEditable & Qt.ItemIsSelectable)
                    item.setBackground(QBrush(QColor(Qt.lightGray)))
                get_atrr = filter_fea_attr.get(field_n)
                item.setData(Qt.DisplayRole, get_atrr)

                # item.setText(get_atrr)
                # item.setCheckState(False)
                # item.setFlags(item.flags() | Qt.ItemIsEditable);
                self.cross_dlg.tabWidget.setItem(n, 1, item)

            if field_values != {}:
                default_val = list(field_values.keys())
                real_val = list(field_values.values())
                # BUG 将查询到的属性，在参数中进行查找，若找到,且顺序索引不为0，则进行首置，查询不到再插入
                # ------------------------------------------------
                insert_attr = str(filter_fea_attr.get(field_n))
                # print(field_n,insert_attr)
                if insert_attr in real_val:
                    idx = real_val.index(insert_attr)
                    insert_attr = default_val[idx]

                if insert_attr == '' or insert_attr == 'NULL':
                    insert_attr = default_val[0]

                # 首置
                #     default_val.pop(idx)
                #     default_val.insert(0, b)
                #     default_val.insert(0,str(filter_fea_attr.get(field_n)))
                # ------------------------------------------------
                # combo1 = self.setComboField(default_val)
                # self.cross_dlg.tabWidget.setCellWidget(n, 1, combo1)
                self.setLineEdit(self.cross_dlg, n, default_val, field_n, insert_attr, edit_status, field_lst)

        self.cross_dlg.tabWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

    def setComboField(self, default_val):
        combo1 = QComboBox()
        combo1.addItems(default_val)
        combo1.setEditable(True)
        return combo1

    def setLineEdit(self, cross_dlg, n, default_val, field_n, insert_attr, edit_status, field_lst):
        appLinkEdit = QLineEdit()
        selectApply = QAction(appLinkEdit)

        selectApply.triggered.connect(
            lambda: self.floatPlane(default_val, appLinkEdit, field_n, selectApply, field_lst, cross_dlg))
        # appLinkEdit.setEnabled(False)
        if edit_status is not None and edit_status == 'enabled_false':
            appLinkEdit.setFocusPolicy(Qt.NoFocus)
        appLinkEdit.addAction(selectApply, QLineEdit.TrailingPosition)
        appLinkEdit.setText(insert_attr)
        selectApply.setIcon(
            QIcon(self.plugin_dir + '/images/field_icons/%s/%s.svg' % (field_n, insert_attr.split(':')[0])))
        cross_dlg.tabWidget.setCellWidget(n, 1, appLinkEdit)

    def floatPlane(self, vals, appLinkEdit, field_n, selectApply, field_lst, cross_dlg):
        self.plane = ActionGroup(self.plugin_dir, vals, appLinkEdit, field_n, selectApply, field_lst, cross_dlg)
        self.plane.show()
        # self.plane.signal.connect(self.accept_msg)

    def cross_submit(self, vlayer, f, cross_dlg):
        # print(self.current_tree_layers,vlayer.name())
        # if self.current_tree_layers[0] is not None:
        #     if self.current_tree_layers[0].name() != vlayer.name():
        #         self.onMsgShow('图层树的选中图层不是%s'%(vlayer.name()))
        #         return

        Attrs = {}
        for rowTabWidget in range(0, cross_dlg.tabWidget.rowCount()):
            item_data = cross_dlg.tabWidget.item(rowTabWidget, 1)
            item_name = cross_dlg.tabWidget.item(rowTabWidget, 0).data(Qt.DisplayRole)
            if '(' in item_name:
                item_name = item_name.split('(')[0]
            item_widget = cross_dlg.tabWidget.cellWidget(rowTabWidget, 1)
            if item_data is not None:
                Attrs.update({item_name: item_data.data(Qt.DisplayRole)})

            if item_widget is not None:
                try:
                    line_edit_text = int(item_widget.text().split(':')[0])
                except:
                    line_edit_text = item_widget.text().split(':')[0]
                # print(line_edit_text)
                Attrs.update({item_name: line_edit_text})

        vlayer.startEditing()
        self.applyToFeature(vlayer, f, Attrs)
        vlayer.commitChanges()

        cross_dlg.reset_btn.setEnabled(False)

    def recalc_hash(self,vertex):
        res = QMessageBox.question(self.cross_dlg, '消息', '确定是否要重新计算路口编号? 重新计算后需要更新路口关联的路段编号!', QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)
        if res == QMessageBox.Yes:
            # new_inter_id = encode(vertex.asPoint().y(),vertex.asPoint().x(), precision=10)+str('0')
            new_inter_id = geo_encode(vertex.asPoint().x(),vertex.asPoint().y())
            item = QTableWidgetItem()
            # item.setText(new_inter_id.upper())
            item.setData(Qt.DisplayRole, new_inter_id.upper())
            self.cross_dlg.tabWidget.setItem(0, 1, item)

    def par_config(self,json_file,json_file_bak):
        # title = self.tr('Parameter Config')
        _this = None
        fr = open(json_file, 'r', encoding='utf-8')
        json_dct = json.loads(fr.read(),
                               object_pairs_hook=OrderedDict)
        json_info = json.dumps(json_dct, indent=2, ensure_ascii=False)
        self.qss = Qss(json_info, json_file, json_file_bak, _this, language='zh')
        self.qss.show()

    # 手工合并路口
    def cross_merge(self):
        #vlayer = self.canvas.currentLayer()
        # print(layer.name())
        if not QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes')) or not QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))[0] or QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))[0].type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取路口数据失败，请先导入路口数据！")
            return
        vlayer =QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))[0]
        select_features = vlayer.selectedFeatures()
        if select_features == []:
            # print(QMessageBox.warning(self.toolbar, '提示', '没有选中要素！'))
            msg = '没有选中要素！'
            self.onMsgShow(msg)
            return

        if select_features != []:
            if len(select_features) < 2:
                # print(QMessageBox.warning(self.toolbar, '提示', '当前选中大于1个要素！'))
                msg = '应选中大于1个要素！'
                self.onMsgShow(msg)
                return
            newFeature=QgsFeature()
            newGeom = QgsGeometry().fromMultiPointXY([])
            osmids=[]
            update_osmid=''
            cross=0
            conn = parseConfig().get('conn')
            vlayer.startEditing()
            for feature in select_features:
                vlayer.deleteFeature(newFeature.id())
                newFeature=feature
                # newFeature.setAttribute(feature.attributes())
                # print(feature.geometry().asWkt())
                if newFeature['cross']==1:
                    cross=1
                osmids+=list(map(int,feature['osmid_original'].strip('[').strip(']').split(',')))
                update_osmid+=( """
                                update {4}.{0} set fnode= {2} where fnode= {3} ;
                                update {4}.{0} set tnode= {2} where tnode= {3} ;
                                
                                """.format(self.config.get('tab_segment'),self.config.get('tab_nodes'),"osmid",int(feature["osmid"]), self.config.get('schema')))
                newGeom=newGeom.combine(feature.geometry())
            # print(newGeom.asWkt())
            print(osmids)
            newFeature['osmid_original'] = str(osmids)
            newFeature['cross'] = cross
            newFeature['x_coord'] = newGeom.centroid().asPoint().x()
            newFeature['y_coord'] = newGeom.centroid().asPoint().y()
            print(newFeature['osmid_original'] )
            newFeature.setGeometry(newGeom.centroid())
            update_osmid=update_osmid.replace('osmid',str(newFeature['osmid']))
            print(update_osmid)
            try:
                vlayer.updateFeature(newFeature)
                vlayer.triggerRepaint()
                vlayer.commitChanges()
                cursor(conn, update_osmid)
                conn.commit()
            except Exception as e:
                print('Exception in cross merge', e)
            self.highlight(newGeom.centroid())
        self.onMsgShow( '路口合并完成！')

    def cross_nomark(self):
        # print(layer.name())
        if not QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes')) or not QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))[0] or  QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))[0].type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取路口数据失败，请先导入路口数据！")
            return
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_nodes'))[0]
        select_features = vlayer.selectedFeatures()
        if select_features == []:
            # print(QMessageBox.warning(self.toolbar, '提示', '没有选中要素！'))
            msg = '没有选中要素！'
            self.onMsgShow(msg)
            return

        if select_features != []:
            newFeature = QgsFeature()
            newGeom = QgsGeometry().fromMultiPointXY([])
            osmids = []
            update_osmid = ''
            cross = 0
            conn = parseConfig().get('conn')
            vlayer.startEditing()
            try:
                for feature in select_features:
                    if feature['cross'] == 1:
                        feature['cross'] = 0
                        vlayer.updateFeature(feature)
                vlayer.triggerRepaint()
                vlayer.commitChanges()
            except Exception as e:
                print('Exception in cross nomark', e)
        self.onMsgShow('岔口标记完成！')
    # 合并道路
    def road_merge(self):
        print('road merge')
        # print(layer.name())
        if not QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment')) or not QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0] or QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0].type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"获取道路数据失败，请先导入道路数据！")
            return
        vlayer = QgsProject.instance().mapLayersByName(parseConfig().get('tab_segment'))[0]
        select_features = vlayer.selectedFeatures()
        if select_features == []:
            # print(QMessageBox.warning(self.toolbar, '提示', '没有选中要素！'))
            msg = '没有选中要素！'
            self.onMsgShow(msg)
            return

        if select_features != []:
            if len(select_features) < 2:
                # print(QMessageBox.warning(self.toolbar, '提示', '当前选中大于1个要素！'))
                msg = '应选中大于1个要素！'
                self.onMsgShow(msg)
                return
            newFeature = QgsFeature()
            newGeom = QgsGeometry().fromPolyline([])
            osmids = []
            names = []
            lst_node = []

            for feature in select_features:
                if lst_node == []:
                    lst_node=[feature]
                print(lst_node)
                for i in range(len(lst_node)):
                    if lst_node[i]['fnode']==feature['tnode']:
                        lst_node.insert(i,feature)
                    elif lst_node[i]['tnode']==feature['fnode']:
                        lst_node.insert(i+1,feature)

            if len(lst_node)<len(select_features):
                # print(QMessageBox.warning(self.toolbar, '提示', '没有能够合并的要素！'))
                msg = '存在不能合并的要素！'
                self.onMsgShow(msg)
                return
            print(lst_node)
            vlayer.startEditing()
            for f in lst_node:
                vlayer.deleteFeature(newFeature.id())
                newFeature = f
                # newFeature.setAttribute(feature.attributes())
                # print(feature.geometry().asWkt())
                osmids += list(map(int, f['osmid'].strip('[').strip(']').split(',')))
                if  f['name']!='' and not names.__contains__(f['name']):
                    names += list(map(str, f['name'].strip('[').strip(']').split(',')))
                newGeom = newGeom.combine(f.geometry())
            #print(str(newGeom.wkbType())+","+str(newGeom.type()))
            if newGeom.isMultipart():
                for part in newGeom.parts():
                    outcoords =[list(i.vertices()) for i in newGeom.parts()]
                newGeom=QgsGeometry().fromPolyline([i for sublist in outcoords for i in sublist])

            #print(osmids)
            newFeature['osmid'] = str(osmids)
            if len(names)>1:
                newFeature['name'] = str(names)
            newFeature['fnode'] = str(lst_node[0]['fnode'])
            newFeature['tnode'] = str(lst_node[len(lst_node)-1]['tnode'])
            newFeature.setGeometry(newGeom)
            try:
                vlayer.updateFeature(newFeature)
                vlayer.triggerRepaint()
                vlayer.commitChanges()
            except Exception as e:
                print('Exception in road merge', e)
            self.highlight(newGeom)
        self.onMsgShow( '道路合并完成！')

    def applyToFeature(self,vlayer, feature, sourceSet):
        '''
        method to apply destination fields cyclying between feature fields
        '''
        for attrId, attrValue in sourceSet.items():
            # print(attrId, attrValue)
            try:
                feature[attrId] = attrValue
                vlayer.updateFeature(feature)
                vlayer.triggerRepaint()
            except Exception as e:
                print('Exception in applyToFeature', e)

    def pick_rid_road_name(self,field_name):
        # self.onMsgShow('拾取......')
        layer = self.iface.layerTreeView().currentLayer()
        # print(layer.name())
        # self.onMsgShow(layer.name())

        if not layer or layer.type() != QgsMapLayerType.VectorLayer:
            QMessageBox.warning(None, u"Error", u"This is not a vector layer.")
            return

        select_features = layer.selectedFeatures()

        if select_features == []:
            # print(QMessageBox.warning(self.toolbar, '提示', '没有选中要素！'))
            msg = '没有选中要素！'
            self.onMsgShow(msg)
            return

        if select_features != []:
            if len(select_features) >= 2:
                # print(QMessageBox.warning(self.toolbar, '提示', '当前选中大于1个要素！'))
                msg = '当前选中大于1个要素！'
                self.onMsgShow(msg)
                return
        if len(select_features) == 1:
            self.add_rid_to_tab(select_features, self.dlg.rid_tab_old,field_name)

    def add_rid_to_tab(self,select_features,rid_tab,filter_field):

        r_id_lst = []
        rid_attrs = self.getTabAttrs(rid_tab)
        for select_feature in select_features:
            fields = select_feature.fields()
            if isinstance(filter_field, str):
                n = [i for i, field in enumerate(fields) if field.name() == filter_field]
                if len(n) > 0:
                    fea_attr = select_feature.attributes()
                    r_id = fea_attr[n[0]]
                    # 去重，重复不再拾取
                    if r_id not in r_id_lst and r_id not in rid_attrs:
                        r_id_lst.append(r_id)
                else:
                    msg = '%s字段不存在'%filter_field
                    # print(QMessageBox.warning(self.toolbar, '提示',msg ))
                    self.onMsgShow(msg)

            elif isinstance(filter_field, list):
                n = [i for i, field in enumerate(fields) if field.name() in filter_field]
                if len(n) > 0:
                    fea_attr = select_feature.attributes()
                    r_id = [str(fea_attr[x]) for x in n]
                    r_id = '|'.join(r_id)
                    if r_id not in r_id_lst and r_id not in rid_attrs:
                        r_id_lst.append(r_id)
                        self.onMsgShow(r_id)

                else:
                    msg = '%s字段不存在'%(','.join(filter_field))
                    self.onMsgShow(msg)


        #将拾取到的rid信息填入表单中
        # rows_rid = len(r_id_lst)
        # rid_tab.setRowCount(n)
        # for i,rid_info in enumerate(r_id_lst):
        #     item = QTableWidgetItem()
        #     item.setData(Qt.DisplayRole, rid_info)
        #     rid_tab.setItem(i,0, item)

        for i, rid_info in enumerate(r_id_lst):
            n = int(rid_tab.rowCount())
            rid_tab.insertRow(n)
            item = QTableWidgetItem()
            item.setData(Qt.DisplayRole, rid_info)
            rid_tab.setItem(n, 0, item)

        rid_tab.resizeColumnsToContents()
        rid_tab.resizeRowsToContents()
        rid_tab.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

    def getTabAttrs(self,tab_widget):
        rid_attrs = []
        rows = tab_widget.rowCount()
        if rows>0:
            for rowTabelWidget in range(0,rows):
                tab_item = tab_widget.item(rowTabelWidget, 0)
                if tab_item is not None:
                    rid_attrs.append(tab_item.data(Qt.DisplayRole))
        return rid_attrs

    def onMsgShow(self,msg):
        if not msg:
            return
        if hasattr(self, "_blabel"):
            self._blabel.stop()
            self._blabel.deleteLater()
            del self._blabel
        self._blabel = BubbleLabel()
        self._blabel.setText(msg)
        self._blabel.show()

    def highlight(self,geometry):
        def processEvents():
            try:
                QApplication.processEvents()
            except:
                QApplication.processEvents()
        highlight = QgsRubberBand(self.canvas, geometry.type())
        highlight.setColor(QColor("#ff0000"))
        highlight.setFillColor(QColor("#ff0000"))
        highlight.setWidth(5)
        highlight.setToGeometry(geometry, self.canvas.currentLayer())
        processEvents()
        sleep(.05)
        highlight.hide()
        highlight.reset()
        processEvents()

    def highlights(self, geometrys,vlayer):
        def processEvents():
            try:
                QApplication.processEvents()
            except:
                QApplication.processEvents()
        highlight = QgsRubberBand(self.canvas, geometrys[0].geometry().type())
        highlight.setColor(QColor("#000000"))
        highlight.setFillColor(QColor("#000000"))
        highlight.setWidth(5)
        for geometry in geometrys:
            highlight.setToGeometry(geometry.geometry(), vlayer)
        processEvents()
        sleep(.05)
        highlight.hide()
        highlight.reset()
        processEvents()


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/pickRoadName.ui'))
class PickDialog(QDialog, FORM_CLASS):
    def __init__(self, iface):
        """Constructor."""
        super(PickDialog, self).__init__()
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowStaysOnTopHint)


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/roadListDockWidget.ui'))
class RoadListDialog(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    def __init__(self, parent=None):
        """Constructor."""
        super(RoadListDialog, self).__init__(parent)

        self.setupUi(self)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/linkListDockWidget.ui'))
class LinkListDialog(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    def __init__(self, parent=None):
        """Constructor."""
        super(LinkListDialog, self).__init__(parent)
        self.setupUi(self)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/ridListDockWidget.ui'))
class RidListDialog(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    def __init__(self, parent=None):
        """Constructor."""
        super(RidListDialog, self).__init__(parent)
        self.setupUi(self)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

FORM_CLASS2, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/attrDialog2.ui'))

class AttrDialog2(QDialog, FORM_CLASS2):
    def __init__(self, iface):
        super(AttrDialog2, self).__init__()
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowStaysOnTopHint)


RID_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/ridDialog.ui'))

class RidDialog(QDialog, RID_CLASS):
    def __init__(self, iface):
        super(RidDialog, self).__init__()
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowStaysOnTopHint)


from functools import partial
class ActionGroup(QMainWindow):
    signal = pyqtSignal(str)
    def __init__(self,plugin_dir,vals,appLinkEdit,field_n,selectApply,field_lst,cross_dlg):
        super(ActionGroup,self).__init__()
        self.resize(500,50)
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.field_n = field_n
        self.field_lst =field_lst
        self.cross_dlg =cross_dlg
        self.setWindowTitle('当前字段: '+field_n)
        self.plugin_dir = plugin_dir
        self.vals = vals
        self.appLinkEdit = appLinkEdit
        self.selectApply = selectApply
        self.initUI()

    def initUI(self):
        tool_actions = []
        for i,val in enumerate(self.vals):
            val =str(val)
            current_icon = os.path.dirname(__file__)+'/images/field_icons/%s/%s.svg'%(self.field_n,val.split(':')[0])
            tool_action = QAction(QIcon(current_icon),val,self)
            tool_actions.append(tool_action)
            # error:tool_actions[-1].triggered.connect(lambda: self.send_signal(val))
            # partial:https://stackoverflow.com/questions/17425367/pyqt4-create-many-buttons-from-dict-dynamically
            tool_actions[-1].triggered.connect(partial(self.send_signal, [val,current_icon]))
        toolbar = QToolBar()
        self.addToolBar(Qt.TopToolBarArea, toolbar)
        toolbar.setIconSize(QSize(70, 70))
        toolbar.addActions(
            tool_actions
        )

    def send_signal(self,val_icon):
        self.appLinkEdit.setText(val_icon[0])
        self.setWindowTitle(self.field_n + ':当前属性值::' + val_icon[0])
        self.selectApply.setIcon(QIcon(val_icon[1]))
        if self.field_n == 'isoneway' and val_icon[0] == '1:是':
            idx = self.field_lst.index('pairsrid') if 'pairsrid' in self.field_lst else None
            # print('pairsrid:',idx)
            item = QTableWidgetItem()
            item.setData(Qt.DisplayRole, '')
            self.cross_dlg.tabWidget.setItem(idx, 1, item)
            # self.cross_dlg.tabWidget.resizeColumnsToContents()
            # self.cross_dlg.tabWidget.resizeRowsToContents()
        # self.signal.emit(current_text)
        self.close()


